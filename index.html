<html>
<head>
<title>INFO 3300 - Data-driven Web Applications</title>
<link href="https://fonts.googleapis.com/css?family=Alegreya|Alegreya+Sans" rel\
="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/default.min.css">
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
<style>
body { font-family: 'Alegreya Sans', Calibri, sans-serif; }
svg { border: solid #ccc 1px; }
rect {
	fill: grey;
}

.background {
	fill: black;
}
.butter{
	fill: #069FC2;
}
.cream {
	fill: #069FC2;
}
.milk {
	fill: #069FC2;
}
/*.egg {
	fill: #99C6BC;
}
.tomato{
	fill: #FFD93B;
}
.corn {
	fill:yellow;
}
.onion {
	fill: purple;
}
.garlic {
	fill: white;
}
.cayenne {
	fill: #F8CE8B;
}
.olive_oil {
	fill: #552E85;
}
.fish {
	fill: #B8E986;
}
/*.wheat {
	fill: #BA8733;
}*/
</style>
</head>
<body>

<svg id = "left" width="3000" height="1700">
  <g id = 'graph'></g>
  <g id = 'icons'></g>
</svg>

<script>
	function returnFirstXKeys (object, x = 10, index = []) {
		// Initilize a keys variable
		// Object.keys returns an array of keys in string type
		var keys = Object.keys(object);
		// Checks if the first ten keys exists in the index array
		// If not, the key will be pushed into the index array
		for (var i = 0; i < x; i++) {
			if(!index.find(function(element){return element === keys[i]})) {
				index.push(keys[i]);
			}
		}
		// Returns index (if needed)
		return index;
	}
	function countByCuisineType (data) {
		// Initilize cuisineTypeIndex object to store cuisineType count
		cuisineTypeIndex = {};
		// Checks if the cuisineType exists in the cuisineTypeIndex object
		// If not, it will set the cuisineType count to 1
		// Otherwise, it will add 1 to the count
		data.forEach(function(recipe){
			if(cuisineTypeIndex[recipe['cuisineType']] === undefined) {
				cuisineTypeIndex[recipe['cuisineType']] = 1;
			} else {
				cuisineTypeIndex[recipe['cuisineType']] += 1;
			}
		});
		return cuisineTypeIndex;
	}
	function filterByCuisineType (data, type) {
		// Checks if object key "cuisine" matches filtered specified type
		// Returns array of recipe objects filtered by specified type
		return data.filter(function(row) {
			return row['cuisineType'] === type;
		});
	}
	function countIngredients (data) {
		// initilize ingredientsIndex object to store ingredient count
		var ingredientsIndex = {};
		// Checks if the ingredient exists in the ingredientsIndex object
		// If not, it will set the ingredient count to 1
		// Otherwise, it will add 1 to the count
		for (var i = 0; i < data.length; i++) {
			data[i].ingredients.forEach(function(ingredient) {
				if(ingredientsIndex[ingredient] === undefined) {
					ingredientsIndex[ingredient] = 1;
				} else {
					ingredientsIndex[ingredient] += 1;
				}
			})
		}
		// return ingredientsIndex after ingredient count sorted by descending order
		return sortObjectValuesByDescendingOrder(ingredientsIndex);
	}
	function sortObjectValuesByDescendingOrder(obj) {
		var sortedObj = {};
		var sortable = [];
		// Pushes object keys and values into an array (to be sorted later)
	  for (var key in obj) {
	    sortable.push([key, obj[key]]);
	  }
		// Sorts objects by descending order
	  sortable.sort(function(a, b) {
	    return b[1] - a[1];
	  });
		// Moves keys and values pairs into an object
		sortable.forEach(function(item) {
	    sortedObj[item[0]] = item[1];
	  });
		// Returns object organized by descending order of values
		return sortedObj;
	}
	function convertObjValuesToPercentages (obj, total) {
		// Initilize new object (as not to change original object)
		var newObj = {};
		// Do the math
		for (var key in obj) {
	    newObj[key] = obj[key] / total * 100;
	  }
		// Return new object
		return newObj;
	}


	var svg = d3.select('#graph');
  	var cuisine_types = ['North American', 'Western European', 'Northern European','Eastern European', 'Southern European', 'Latin American', 'Middle Eastern', 'African', 'South Asian', 'Southeast Asian', 'East Asian',];
  	var x_scale = d3.scaleLinear().domain([0,90]).range([0,175]);
 	var svg_width = 22 + cuisine_types.length*(10 + x_scale(90));
 	d3.select("svg").attr("width", svg_width);
	//creates axis
	var x_axis = d3.axisTop(x_scale).ticks(7);
	//import cuisines.csv
	d3.text("cuisines.csv", function(error, data){
		rawData = d3.csvParseRows(data, function(row) {
			var ingredients = [];
			// Filter out ingredient columns that are undefined
			for (var i = 1; i < row.length; i++) {
				ingredients.push(row[i]);
				if (row[i+1] === '') { break;}
			}
			return {
				cuisineType: row[0],
				ingredients: ingredients
			};
		});
		var processedData = [];
		var topIngredientsIndex = [];
		var cuisineTypesByCount = countByCuisineType(rawData);
		for (var cuisineType in cuisineTypesByCount) {
			var cuisineTypeCount = cuisineTypesByCount[cuisineType];
			var ingredientsByCount = countIngredients(filterByCuisineType(rawData, cuisineType));
			var ingredientsByPercentage = convertObjValuesToPercentages(ingredientsByCount, cuisineTypeCount);
			processedData.push({
				cuisineType: cuisineType,
				totalNumberOfRecipes:cuisineTypeCount,
				ingredientsByCount:ingredientsByCount,
				ingredientsByPercentage:ingredientsByPercentage
			});
			returnFirstXKeys(ingredientsByCount, 5, topIngredientsIndex);
		}
		console.log(processedData);
		console.log(topIngredientsIndex);

		var cat = [];

		cuisine_types.forEach(function(cuisine_type) {
				processedData.forEach(function(dataSet) {
					if (dataSet.cuisineType === cuisine_type.replace(/\s/g, "")) {
						cat.push(dataSet);
					}
			});
		});

		cat.forEach(function(d, i){
			var obj = {};
			topIngredientsIndex.forEach(function(ingredient){
					obj[ingredient] = (d.ingredientsByPercentage[ingredient] !== undefined ? d.ingredientsByPercentage[ingredient] : 0);
			});
			var sortedObj = sortObjectValuesByDescendingOrder(obj);
			console.log(d.cuisineType);
			console.log(sortedObj[Object.keys(sortedObj)[0]]);
			//creates axises and background grey rectangle for each cuisine type, axises are currently left aligned
			//axises need to be updated to start in the center if we're still doing that
			var x_coord = 22 + (i*(10 + x_scale(90)));
			svg.append("g").attr("transform", "translate(" + x_coord + ", 40)").call(x_axis);
			svg.append("text")
			.attr("x", x_coord)
			.attr("y", 15)
			.text(cuisine_types[i]);
			svg.append("rect")
			.attr("x", x_coord)
			.attr("y", 45)
			.attr("width", x_scale(90) +3)
			.attr("height", topIngredientsIndex.length * 50)
			.style("fill-opacity", .15)
			.attr("class", "background");
			var counts = Object.values(sortedObj);
			console.log(counts);
			var j = 0;
			for (var ingredient in sortedObj) {
				var width = x_scale(sortedObj[ingredient])
				svg.append("rect")
				.attr("x", x_coord)
				.attr("y", 47+(j*50))
				.attr("width", width)
				.attr("height", 45)
				.attr("class", ingredient)
				d3.select("#icons").append("svg:image")
				.attr("xlink:href", "images/"+ingredient+".svg")
				.attr("height", 35)
				.attr("id", ingredient + i);
				// if (width < x_scale(20)){
				// 	console.log(document.getElementById(ingredient+i).style.width);
				x_trans = x_coord + width + 7;
				// }
				// else {
				// 	x_trans = x_coord+5
				// }
				var transformation = "translate("+ x_trans + ', '+ (53+(j*50)) +')';
				d3.select("#"+ingredient+i).attr("transform", transformation)
				j++;
			}
		});
	});

  // Add the bars to a column of the svg element.
 </script>


</body>
</html>
